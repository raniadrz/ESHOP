import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';
import { updateGroupDefaultExpansion, getGroupRowIdFromPath, insertNodeInTree, updateGroupNodeIdAndAutoGenerated } from './utils';
/**
 * Inserts a data row in a tree.
 * For each steps of its path:
 * - if a node exists with the same partial path, it will register this node as the ancestor of the data row.
 * - if not, it will create an auto-generated node and register it as ancestor of the data row.
 */
export var insertDataRowInTree = function insertDataRowInTree(_ref) {
  var id = _ref.id,
    path = _ref.path,
    updatedGroupsManager = _ref.updatedGroupsManager,
    previousTree = _ref.previousTree,
    tree = _ref.tree,
    treeDepths = _ref.treeDepths,
    onDuplicatePath = _ref.onDuplicatePath,
    isGroupExpandedByDefault = _ref.isGroupExpandedByDefault,
    defaultGroupingExpansionDepth = _ref.defaultGroupingExpansionDepth;
  var parentNodeId = GRID_ROOT_GROUP_ID;
  for (var depth = 0; depth < path.length; depth += 1) {
    var _childrenFromPath;
    var _path$depth = path[depth],
      key = _path$depth.key,
      field = _path$depth.field;
    var fieldWithDefaultValue = field != null ? field : '__no_field__';
    var keyWithDefaultValue = key != null ? key : '__no_key__';
    var existingNodeIdWithPartialPath = (_childrenFromPath = tree[parentNodeId].childrenFromPath) == null || (_childrenFromPath = _childrenFromPath[fieldWithDefaultValue]) == null ? void 0 : _childrenFromPath[keyWithDefaultValue.toString()];

    // When we reach the last step of the path,
    // We need to create a node for the row passed to `insertNodeInTree`
    if (depth === path.length - 1) {
      // If no node matches the full path,
      // We create a leaf node for the data row.
      if (existingNodeIdWithPartialPath == null) {
        var leafNode = {
          type: 'leaf',
          id: id,
          depth: depth,
          parent: parentNodeId,
          groupingKey: key
        };
        updatedGroupsManager == null || updatedGroupsManager.addAction(parentNodeId, 'insertChildren');
        insertNodeInTree(leafNode, tree, treeDepths, previousTree);
      } else {
        var existingNodeWithPartialPath = tree[existingNodeIdWithPartialPath];

        // If we already have an auto-generated group matching the partial path,
        // We replace it with the node from of data row passed to `insertNodeInTree`
        if (existingNodeWithPartialPath.type === 'group' && existingNodeWithPartialPath.isAutoGenerated) {
          updatedGroupsManager == null || updatedGroupsManager.addAction(parentNodeId, 'removeChildren');
          updatedGroupsManager == null || updatedGroupsManager.addAction(parentNodeId, 'insertChildren');
          updateGroupNodeIdAndAutoGenerated({
            tree: tree,
            previousTree: previousTree,
            treeDepths: treeDepths,
            node: existingNodeWithPartialPath,
            updatedNode: {
              id: id,
              isAutoGenerated: false
            }
          });
        } else {
          // If we have another row matching the partial path, then there is a duplicate in the dataset.
          // We warn the user and skip the current row.
          onDuplicatePath == null || onDuplicatePath(existingNodeIdWithPartialPath, id, path);
        }
      }
    }
    // For the intermediary steps of the path,
    // We need to make sure that there is a node matching the partial path.
    //
    // If no node matches the partial path,
    // We create an auto-generated group node.
    else if (existingNodeIdWithPartialPath == null) {
      var nodeId = getGroupRowIdFromPath(path.slice(0, depth + 1));
      var autoGeneratedGroupNode = {
        type: 'group',
        id: nodeId,
        parent: parentNodeId,
        depth: depth,
        isAutoGenerated: true,
        groupingKey: key,
        groupingField: field,
        children: [],
        childrenFromPath: {},
        childrenExpanded: false
      };
      updatedGroupsManager == null || updatedGroupsManager.addAction(parentNodeId, 'insertChildren');
      insertNodeInTree(updateGroupDefaultExpansion(autoGeneratedGroupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault), tree, treeDepths, previousTree);
      parentNodeId = nodeId;
    }
    // For the intermediary steps of the path
    // If a node matches the partial path, we use it as parent for the next step
    else {
      var currentGroupNode = tree[existingNodeIdWithPartialPath];

      // If the node matching the partial path is not a group, we turn it into a group
      if (currentGroupNode.type !== 'group') {
        var groupNode = {
          type: 'group',
          id: currentGroupNode.id,
          parent: currentGroupNode.parent,
          depth: currentGroupNode.depth,
          isAutoGenerated: false,
          groupingKey: key,
          groupingField: field,
          children: [],
          childrenFromPath: {},
          childrenExpanded: false
        };
        tree[existingNodeIdWithPartialPath] = updateGroupDefaultExpansion(groupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault);
      }
      parentNodeId = currentGroupNode.id;
    }
  }
};