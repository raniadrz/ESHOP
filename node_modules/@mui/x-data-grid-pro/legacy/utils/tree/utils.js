import _extends from "@babel/runtime/helpers/esm/extends";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';
export var getGroupRowIdFromPath = function getGroupRowIdFromPath(path) {
  var pathStr = path.map(function (groupingCriteria) {
    return "".concat(groupingCriteria.field, "/").concat(groupingCriteria.key);
  }).join('-');
  return "auto-generated-row-".concat(pathStr);
};
export var getNodePathInTree = function getNodePathInTree(_ref) {
  var id = _ref.id,
    tree = _ref.tree;
  var path = [];
  var node = tree[id];
  while (node.id !== GRID_ROOT_GROUP_ID) {
    path.push({
      field: node.type === 'leaf' ? null : node.groupingField,
      key: node.groupingKey
    });
    node = tree[node.parent];
  }
  path.reverse();
  return path;
};
export var updateGroupDefaultExpansion = function updateGroupDefaultExpansion(node, defaultGroupingExpansionDepth, isGroupExpandedByDefault) {
  var childrenExpanded;
  if (node.id === GRID_ROOT_GROUP_ID) {
    childrenExpanded = true;
  } else if (isGroupExpandedByDefault) {
    childrenExpanded = isGroupExpandedByDefault(node);
  } else {
    childrenExpanded = defaultGroupingExpansionDepth === -1 || defaultGroupingExpansionDepth > node.depth;
  }
  node.childrenExpanded = childrenExpanded;
  return node;
};

/**
 * Insert a node in the tree
 */
export var insertNodeInTree = function insertNodeInTree(node, tree, treeDepths, previousTree) {
  var _treeDepths$node$dept;
  // 1. Insert node in the tree.
  tree[node.id] = node;

  // 2. Increment the `treeDepths` object for the node's depth.
  treeDepths[node.depth] = ((_treeDepths$node$dept = treeDepths[node.depth]) != null ? _treeDepths$node$dept : 0) + 1;

  // 3. Register the new node in its parent.
  var parentNode = tree[node.parent];
  if (node.type === 'group' || node.type === 'leaf') {
    var _groupingField, _groupingKey, _parentNode$childrenF;
    // For groups and leaves,
    // Register the node from its parents `children` and `childrenFromPath` properties.
    var groupingFieldName = (_groupingField = node.groupingField) != null ? _groupingField : '__no_field__';
    var groupingKeyName = (_groupingKey = node.groupingKey) != null ? _groupingKey : '__no_key__';
    var groupingField = (_parentNode$childrenF = parentNode.childrenFromPath) == null ? void 0 : _parentNode$childrenF[groupingFieldName];
    if (previousTree !== null && previousTree[parentNode.id] === tree[parentNode.id]) {
      parentNode.children = [].concat(_toConsumableArray(parentNode.children), [node.id]);
    } else {
      parentNode.children.push(node.id);
    }
    if (groupingField == null) {
      parentNode.childrenFromPath[groupingFieldName] = _defineProperty({}, groupingKeyName.toString(), node.id);
    } else {
      groupingField[groupingKeyName.toString()] = node.id;
    }
  } else if (node.type === 'footer') {
    // For footers,
    // Register the node from its parent `footerId` property.
    parentNode.footerId = node.id;
  }
};

/**
 * Removes a node from the tree
 */
export var removeNodeFromTree = function removeNodeFromTree(_ref2) {
  var node = _ref2.node,
    tree = _ref2.tree,
    treeDepths = _ref2.treeDepths;
  // 1. Remove node from the tree.
  delete tree[node.id];

  // 2. Decrement the `treeDepths` object for the node's depth.
  var nodeDepth = node.depth;
  var currentNodeCount = treeDepths[nodeDepth];
  if (currentNodeCount === 1) {
    delete treeDepths[nodeDepth];
  } else {
    treeDepths[nodeDepth] = currentNodeCount - 1;
  }

  // 3. Unregister the new node in its parent.
  var parentNode = tree[node.parent];
  // For footers,
  // Unregister the node from its parent `footerId` property.
  if (node.type === 'footer') {
    tree[parentNode.id] = _extends({}, parentNode, {
      footerId: null
    });
  }
  // For groups and leaves,
  // Unregister the node from its parents `children` and `childrenFromPath` properties.
  else {
    var _groupingField2, _groupingKey2;
    var groupingField = (_groupingField2 = node.groupingField) != null ? _groupingField2 : '__no_field__';
    var groupingKey = (_groupingKey2 = node.groupingKey) != null ? _groupingKey2 : '__no_key__';

    // TODO rows v6: Can we avoid this linear complexity ?
    var children = parentNode.children.filter(function (childId) {
      return childId !== node.id;
    });
    var childrenFromPath = parentNode.childrenFromPath;
    delete childrenFromPath[groupingField][groupingKey.toString()];
    tree[parentNode.id] = _extends({}, parentNode, {
      children: children,
      childrenFromPath: childrenFromPath
    });
  }
};

/**
 * Updates the `id` and `isAutoGenerated` properties of a group node.
 */
export var updateGroupNodeIdAndAutoGenerated = function updateGroupNodeIdAndAutoGenerated(_ref3) {
  var node = _ref3.node,
    updatedNode = _ref3.updatedNode,
    previousTree = _ref3.previousTree,
    tree = _ref3.tree,
    treeDepths = _ref3.treeDepths;
  // 1. Set the new parent for all children from the old group
  node.children.forEach(function (childId) {
    tree[childId] = _extends({}, tree[childId], {
      parent: updatedNode.id
    });
  });

  // 2. Remove the old group from the tree
  removeNodeFromTree({
    node: node,
    tree: tree,
    treeDepths: treeDepths
  });

  // 3. Add the new group in the tree
  var groupNode = _extends({}, node, updatedNode);
  insertNodeInTree(groupNode, tree, treeDepths, previousTree);
};
export var createUpdatedGroupsManager = function createUpdatedGroupsManager() {
  return {
    value: {},
    addAction: function addAction(groupId, action) {
      if (!this.value[groupId]) {
        this.value[groupId] = {};
      }
      this.value[groupId][action] = true;
    }
  };
};
export var getVisibleRowsLookup = function getVisibleRowsLookup(_ref4) {
  var tree = _ref4.tree,
    filteredRowsLookup = _ref4.filteredRowsLookup;
  if (!filteredRowsLookup) {
    return {};
  }
  var visibleRowsLookup = {};
  var handleTreeNode = function handleTreeNode(node, areAncestorsExpanded) {
    var isPassingFiltering = filteredRowsLookup[node.id];
    if (node.type === 'group') {
      node.children.forEach(function (childId) {
        var childNode = tree[childId];
        handleTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded);
      });
    }
    visibleRowsLookup[node.id] = isPassingFiltering && areAncestorsExpanded;

    // TODO rows v6: Should we keep storing the visibility status of footer independently or rely on the group visibility in the selector ?
    if (node.type === 'group' && node.footerId != null) {
      visibleRowsLookup[node.footerId] = isPassingFiltering && areAncestorsExpanded && !!node.childrenExpanded;
    }
  };
  var nodes = Object.values(tree);
  for (var i = 0; i < nodes.length; i += 1) {
    var node = nodes[i];
    if (node.depth === 0) {
      handleTreeNode(node, true);
    }
  }
  return visibleRowsLookup;
};