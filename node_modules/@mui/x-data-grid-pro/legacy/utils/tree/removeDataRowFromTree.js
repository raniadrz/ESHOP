import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';
import { getNodePathInTree, getGroupRowIdFromPath, removeNodeFromTree, updateGroupNodeIdAndAutoGenerated } from './utils';
var removeNodeAndCleanParent = function removeNodeAndCleanParent(_ref) {
  var node = _ref.node,
    tree = _ref.tree,
    treeDepths = _ref.treeDepths,
    updatedGroupsManager = _ref.updatedGroupsManager;
  removeNodeFromTree({
    node: node,
    tree: tree,
    treeDepths: treeDepths
  });
  if (node.type === 'group' && node.footerId != null) {
    removeNodeFromTree({
      node: tree[node.footerId],
      tree: tree,
      treeDepths: treeDepths
    });
  }
  var parentNode = tree[node.parent];
  updatedGroupsManager == null || updatedGroupsManager.addAction(parentNode.id, 'removeChildren');
  var shouldDeleteGroup = parentNode.id !== GRID_ROOT_GROUP_ID && parentNode.children.length === 0;
  if (shouldDeleteGroup) {
    if (parentNode.isAutoGenerated) {
      removeNodeAndCleanParent({
        node: parentNode,
        tree: tree,
        treeDepths: treeDepths
      });
    } else {
      tree[parentNode.id] = {
        type: 'leaf',
        id: parentNode.id,
        depth: parentNode.depth,
        parent: parentNode.parent,
        groupingKey: parentNode.groupingKey
      };
    }
  }
};
var replaceDataGroupWithAutoGeneratedGroup = function replaceDataGroupWithAutoGeneratedGroup(_ref2) {
  var node = _ref2.node,
    tree = _ref2.tree,
    treeDepths = _ref2.treeDepths,
    updatedGroupsManager = _ref2.updatedGroupsManager;
  updatedGroupsManager == null || updatedGroupsManager.addAction(node.parent, 'removeChildren');
  updatedGroupsManager == null || updatedGroupsManager.addAction(node.parent, 'insertChildren');
  updateGroupNodeIdAndAutoGenerated({
    previousTree: null,
    tree: tree,
    treeDepths: treeDepths,
    node: node,
    updatedNode: {
      id: getGroupRowIdFromPath(getNodePathInTree({
        id: node.id,
        tree: tree
      })),
      isAutoGenerated: true
    }
  });
};

/**
 * Removed a data row from the tree.
 * If the node is a non-empty group, replace it with an auto-generated group to be able to keep displaying its children.
 * If not, remove it and recursively clean its parent with the following rules:
 * - An empty auto-generated should be removed from the tree
 * - An empty non-auto-generated should be turned into a leaf
 */
export var removeDataRowFromTree = function removeDataRowFromTree(_ref3) {
  var id = _ref3.id,
    tree = _ref3.tree,
    treeDepths = _ref3.treeDepths,
    updatedGroupsManager = _ref3.updatedGroupsManager;
  var node = tree[id];
  if (node.type === 'group' && node.children.length > 0) {
    replaceDataGroupWithAutoGeneratedGroup({
      node: node,
      tree: tree,
      treeDepths: treeDepths,
      updatedGroupsManager: updatedGroupsManager
    });
  } else {
    removeNodeAndCleanParent({
      node: node,
      tree: tree,
      treeDepths: treeDepths,
      updatedGroupsManager: updatedGroupsManager
    });
  }
};