import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
var _excluded = ["colIndex", "height", "hasFocus", "filterOperators", "width", "headerClassName", "colDef", "item", "headerFilterMenuRef", "InputComponentProps", "showClearIcon"];
import * as React from 'react';
import PropTypes from 'prop-types';
import clsx from 'clsx';
import { unstable_useForkRef as useForkRef, unstable_composeClasses as composeClasses, unstable_capitalize as capitalize } from '@mui/utils';
import { gridVisibleColumnFieldsSelector, getDataGridUtilityClass } from '@mui/x-data-grid';
import { useGridPrivateApiContext, unstable_gridHeaderFilteringEditFieldSelector, unstable_gridHeaderFilteringMenuSelector, isNavigationKey } from '@mui/x-data-grid/internals';
import { useGridRootProps } from '../../hooks/utils/useGridRootProps';
import { GridHeaderFilterMenuContainer } from './GridHeaderFilterMenuContainer';
import { GridHeaderFilterClearButton } from './GridHeaderFilterClearButton';
import { jsx as _jsx } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime";
var useUtilityClasses = function useUtilityClasses(ownerState) {
  var colDef = ownerState.colDef,
    classes = ownerState.classes,
    showColumnVerticalBorder = ownerState.showColumnVerticalBorder;
  var slots = {
    root: ['columnHeader', colDef.headerAlign === 'left' && 'columnHeader--alignLeft', colDef.headerAlign === 'center' && 'columnHeader--alignCenter', colDef.headerAlign === 'right' && 'columnHeader--alignRight', 'withBorderColor', showColumnVerticalBorder && 'columnHeader--withRightBorder']
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
var dateSx = _defineProperty({}, "& input[value=\"\"]:not(:focus)", {
  color: 'transparent'
});
var GridHeaderFilterCell = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _filterOperators$find, _currentOperator$head, _colDef$headerName;
  var colIndex = props.colIndex,
    height = props.height,
    hasFocus = props.hasFocus,
    filterOperators = props.filterOperators,
    width = props.width,
    headerClassName = props.headerClassName,
    colDef = props.colDef,
    item = props.item,
    headerFilterMenuRef = props.headerFilterMenuRef,
    InputComponentProps = props.InputComponentProps,
    _props$showClearIcon = props.showClearIcon,
    showClearIcon = _props$showClearIcon === void 0 ? true : _props$showClearIcon,
    other = _objectWithoutProperties(props, _excluded);
  var apiRef = useGridPrivateApiContext();
  var columnFields = gridVisibleColumnFieldsSelector(apiRef);
  var rootProps = useGridRootProps();
  var cellRef = React.useRef(null);
  var handleRef = useForkRef(ref, cellRef);
  var inputRef = React.useRef(null);
  var buttonRef = React.useRef(null);
  var isEditing = unstable_gridHeaderFilteringEditFieldSelector(apiRef) === colDef.field;
  var isMenuOpen = unstable_gridHeaderFilteringMenuSelector(apiRef) === colDef.field;
  var currentOperator = filterOperators[0];
  var InputComponent = colDef.filterable ? currentOperator.InputComponent : null;
  var applyFilterChanges = React.useCallback(function (updatedItem) {
    if (item.value && !updatedItem.value) {
      apiRef.current.deleteFilterItem(updatedItem);
      return;
    }
    apiRef.current.upsertFilterItem(updatedItem);
  }, [apiRef, item]);
  var clearFilterItem = React.useCallback(function () {
    apiRef.current.deleteFilterItem(item);
  }, [apiRef, item]);
  var headerFilterComponent;
  if (colDef.renderHeaderFilter) {
    headerFilterComponent = colDef.renderHeaderFilter(props);
  }
  React.useLayoutEffect(function () {
    if (hasFocus && !isMenuOpen) {
      var _apiRef$current$colum;
      var focusableElement = cellRef.current.querySelector('[tabindex="0"]');
      if (isEditing && InputComponent) {
        focusableElement = inputRef.current;
      }
      var elementToFocus = focusableElement || cellRef.current;
      elementToFocus == null || elementToFocus.focus();
      if ((_apiRef$current$colum = apiRef.current.columnHeadersContainerElementRef) != null && _apiRef$current$colum.current) {
        apiRef.current.columnHeadersContainerElementRef.current.scrollLeft = 0;
      }
    }
  }, [InputComponent, apiRef, hasFocus, isEditing, isMenuOpen]);
  var onKeyDown = React.useCallback(function (event) {
    if (isMenuOpen || isNavigationKey(event.key)) {
      return;
    }
    switch (event.key) {
      case 'Escape':
        if (isEditing) {
          apiRef.current.stopHeaderFilterEditMode();
        }
        break;
      case 'Enter':
        if (isEditing) {
          apiRef.current.stopHeaderFilterEditMode();
          break;
        }
        if (event.metaKey || event.ctrlKey) {
          headerFilterMenuRef.current = buttonRef.current;
          apiRef.current.showHeaderFilterMenu(colDef.field);
          break;
        }
        apiRef.current.startHeaderFilterEditMode(colDef.field);
        break;
      case 'Tab':
        {
          if (isEditing) {
            var _columnFields;
            var fieldToFocus = (_columnFields = columnFields[colIndex + (event.shiftKey ? -1 : 1)]) != null ? _columnFields : null;
            if (fieldToFocus) {
              apiRef.current.startHeaderFilterEditMode(fieldToFocus);
              apiRef.current.setColumnHeaderFilterFocus(fieldToFocus, event);
            }
          }
          break;
        }
      default:
        if (isEditing || event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) {
          break;
        }
        apiRef.current.startHeaderFilterEditMode(colDef.field);
        break;
    }
  }, [apiRef, colDef.field, colIndex, columnFields, headerFilterMenuRef, isEditing, isMenuOpen]);
  var publish = React.useCallback(function (eventName, propHandler) {
    return function (event) {
      apiRef.current.publishEvent(eventName, apiRef.current.getColumnHeaderParams(colDef.field), event);
      if (propHandler) {
        propHandler(event);
      }
    };
  }, [apiRef, colDef.field]);
  var onMouseDown = React.useCallback(function (event) {
    if (!hasFocus) {
      if (inputRef.current && inputRef.current.contains(event.target)) {
        inputRef.current.focus();
      }
      apiRef.current.setColumnHeaderFilterFocus(colDef.field, event);
    }
  }, [apiRef, colDef.field, hasFocus]);
  var mouseEventsHandlers = React.useMemo(function () {
    return {
      onKeyDown: publish('headerFilterKeyDown', onKeyDown),
      onClick: publish('headerFilterClick'),
      onMouseDown: publish('headerFilterMouseDown', onMouseDown),
      onBlur: publish('headerFilterBlur')
    };
  }, [onMouseDown, onKeyDown, publish]);
  var ownerState = _extends({}, rootProps, {
    colDef: colDef
  });
  var classes = useUtilityClasses(ownerState);
  var isNoInputOperator = (filterOperators == null || (_filterOperators$find = filterOperators.find(function (_ref) {
    var value = _ref.value;
    return item.operator === value;
  })) == null ? void 0 : _filterOperators$find.requiresFilterValue) === false;
  var isApplied = Boolean(item == null ? void 0 : item.value) || isNoInputOperator;
  var label = (_currentOperator$head = currentOperator.headerLabel) != null ? _currentOperator$head : apiRef.current.getLocaleText("headerFilterOperator".concat(capitalize(item.operator)));
  var isFilterActive = isApplied || hasFocus;
  return /*#__PURE__*/_jsxs("div", _extends({
    className: clsx(classes.root, headerClassName),
    ref: handleRef,
    style: {
      height: height,
      width: width,
      minWidth: width,
      maxWidth: width
    },
    role: "columnheader",
    "aria-colindex": colIndex + 1,
    "aria-label": headerFilterComponent == null ? (_colDef$headerName = colDef.headerName) != null ? _colDef$headerName : colDef.field : undefined
  }, other, mouseEventsHandlers, {
    children: [headerFilterComponent, InputComponent && headerFilterComponent === undefined ? /*#__PURE__*/_jsxs(React.Fragment, {
      children: [/*#__PURE__*/_jsx(InputComponent, _extends({
        apiRef: apiRef,
        item: item,
        inputRef: inputRef,
        applyValue: applyFilterChanges,
        onFocus: function onFocus() {
          return apiRef.current.startHeaderFilterEditMode(colDef.field);
        },
        onBlur: function onBlur(event) {
          var _event$relatedTarget;
          apiRef.current.stopHeaderFilterEditMode();
          // Blurring an input element should reset focus state only if `relatedTarget` is not the header filter cell
          if (!((_event$relatedTarget = event.relatedTarget) != null && _event$relatedTarget.className.includes('columnHeader'))) {
            apiRef.current.setState(function (state) {
              return _extends({}, state, {
                focus: {
                  cell: null,
                  columnHeader: null,
                  columnHeaderFilter: null,
                  columnGroupHeader: null
                }
              });
            });
          }
        },
        label: capitalize(label),
        placeholder: "",
        isFilterActive: isFilterActive,
        clearButton: showClearIcon && isApplied ? /*#__PURE__*/_jsx(GridHeaderFilterClearButton, {
          onClick: clearFilterItem
        }) : null,
        disabled: isNoInputOperator,
        tabIndex: -1,
        InputLabelProps: null,
        sx: colDef.type === 'date' || colDef.type === 'dateTime' ? dateSx : undefined
      }, isNoInputOperator ? {
        value: ''
      } : {}, currentOperator == null ? void 0 : currentOperator.InputComponentProps, InputComponentProps)), /*#__PURE__*/_jsx(GridHeaderFilterMenuContainer, {
        operators: filterOperators,
        item: item,
        field: colDef.field,
        applyFilterChanges: applyFilterChanges,
        headerFilterMenuRef: headerFilterMenuRef,
        buttonRef: buttonRef
      })]
    }) : null]
  }));
});
process.env.NODE_ENV !== "production" ? GridHeaderFilterCell.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  colDef: PropTypes.object.isRequired,
  colIndex: PropTypes.number.isRequired,
  filterOperators: PropTypes.arrayOf(PropTypes.shape({
    getApplyFilterFn: PropTypes.func.isRequired,
    getApplyFilterFnV7: PropTypes.func,
    getValueAsString: PropTypes.func,
    headerLabel: PropTypes.string,
    InputComponent: PropTypes.elementType,
    InputComponentProps: PropTypes.object,
    label: PropTypes.string,
    requiresFilterValue: PropTypes.bool,
    value: PropTypes.string.isRequired
  })),
  hasFocus: PropTypes.bool,
  /**
   * Class name that will be added in the column header cell.
   */
  headerClassName: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  headerFilterMenuRef: PropTypes.shape({
    current: PropTypes.object
  }).isRequired,
  height: PropTypes.number.isRequired,
  InputComponentProps: PropTypes.object,
  item: PropTypes.shape({
    field: PropTypes.string.isRequired,
    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    operator: PropTypes.string.isRequired,
    value: PropTypes.any
  }).isRequired,
  showClearIcon: PropTypes.bool,
  sortIndex: PropTypes.number,
  tabIndex: PropTypes.oneOf([-1, 0]).isRequired,
  width: PropTypes.number.isRequired
} : void 0;
export { GridHeaderFilterCell };