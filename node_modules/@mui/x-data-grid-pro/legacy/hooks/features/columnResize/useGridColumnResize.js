import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _extends from "@babel/runtime/helpers/esm/extends";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import * as React from 'react';
import { unstable_ownerDocument as ownerDocument, unstable_useEventCallback as useEventCallback } from '@mui/utils';
import { gridClasses, useGridApiEventHandler, useGridApiOptionHandler, useGridApiMethod, useGridNativeEventListener, useGridLogger, useGridSelector, gridVirtualizationColumnEnabledSelector } from '@mui/x-data-grid';
import { clamp, findParentElementFromClassName, gridColumnsStateSelector, useOnMount, useTimeout, createControllablePromise } from '@mui/x-data-grid/internals';
import { useTheme } from '@mui/material/styles';
import { findGridCellElementsFromCol, getFieldFromHeaderElem, findHeaderElementFromField, findGroupHeaderElementsFromField, findGridHeader, findGridCells } from '../../../utils/domUtils';
import { DEFAULT_GRID_AUTOSIZE_OPTIONS } from './gridColumnResizeApi';
// TODO: remove support for Safari < 13.
// https://caniuse.com/#search=touch-action
//
// Safari, on iOS, supports touch action since v13.
// Over 80% of the iOS phones are compatible
// in August 2020.
// Utilizing the CSS.supports method to check if touch-action is supported.
// Since CSS.supports is supported on all but Edge@12 and IE and touch-action
// is supported on both Edge@12 and IE if CSS.supports is not available that means that
// touch-action will be supported
var cachedSupportsTouchActionNone = false;
function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === undefined) {
    if (typeof CSS !== 'undefined' && typeof CSS.supports === 'function') {
      cachedSupportsTouchActionNone = CSS.supports('touch-action', 'none');
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }
  return cachedSupportsTouchActionNone;
}
function trackFinger(event, currentTouchId) {
  if (currentTouchId !== undefined && event.changedTouches) {
    for (var i = 0; i < event.changedTouches.length; i += 1) {
      var touch = event.changedTouches[i];
      if (touch.identifier === currentTouchId) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return false;
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function computeNewWidth(initialOffsetToSeparator, clickX, columnBounds, resizeDirection) {
  var newWidth = initialOffsetToSeparator;
  if (resizeDirection === 'Right') {
    newWidth += clickX - columnBounds.left;
  } else {
    newWidth += columnBounds.right - clickX;
  }
  return newWidth;
}
function computeOffsetToSeparator(clickX, columnBounds, resizeDirection) {
  if (resizeDirection === 'Left') {
    return clickX - columnBounds.left;
  }
  return columnBounds.right - clickX;
}
function flipResizeDirection(side) {
  if (side === 'Right') {
    return 'Left';
  }
  return 'Right';
}
function getResizeDirection(element, direction) {
  var side = element.classList.contains(gridClasses['columnSeparator--sideRight']) ? 'Right' : 'Left';
  if (direction === 'rtl') {
    // Resizing logic should be mirrored in the RTL case
    return flipResizeDirection(side);
  }
  return side;
}
function preventClick(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

/**
 * Checker that returns a promise that resolves when the column virtualization
 * is disabled.
 */
function useColumnVirtualizationDisabled(apiRef) {
  var promise = React.useRef();
  var selector = function selector() {
    return gridVirtualizationColumnEnabledSelector(apiRef);
  };
  var value = useGridSelector(apiRef, selector);
  React.useEffect(function () {
    if (promise.current && value === false) {
      promise.current.resolve();
      promise.current = undefined;
    }
  });
  var asyncCheck = function asyncCheck() {
    if (!promise.current) {
      if (selector() === false) {
        return Promise.resolve();
      }
      promise.current = createControllablePromise();
    }
    return promise.current;
  };
  return asyncCheck;
}

/**
 * Basic statistical outlier detection, checks if the value is `F * IQR` away from
 * the Q1 and Q3 boundaries. IQR: interquartile range.
 */
function excludeOutliers(inputValues, factor) {
  if (inputValues.length < 4) {
    return inputValues;
  }
  var values = inputValues.slice();
  values.sort(function (a, b) {
    return a - b;
  });
  var q1 = values[Math.floor(values.length * 0.25)];
  var q3 = values[Math.floor(values.length * 0.75) - 1];
  var iqr = q3 - q1;

  // We make a small adjustment if `iqr < 5` for the cases where the IQR is
  // very small (e.g. zero) due to very close by values in the input data.
  // Otherwise, with an IQR of `0`, anything outside that would be considered
  // an outlier, but it makes more sense visually to allow for this 5px variance
  // rather than showing a cropped cell.
  var deviation = iqr < 5 ? 5 : iqr * factor;
  return values.filter(function (v) {
    return v > q1 - deviation && v < q3 + deviation;
  });
}
function extractColumnWidths(apiRef, options, columns) {
  var widthByField = {};
  var root = apiRef.current.rootElementRef.current;
  root.classList.add(gridClasses.autosizing);
  columns.forEach(function (column) {
    var cells = findGridCells(apiRef.current, column.field);
    var widths = cells.map(function (cell) {
      var _cell$firstElementChi, _cell$firstElementChi2;
      var style = window.getComputedStyle(cell, null);
      var paddingWidth = parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);
      var contentWidth = (_cell$firstElementChi = (_cell$firstElementChi2 = cell.firstElementChild) == null ? void 0 : _cell$firstElementChi2.getBoundingClientRect().width) != null ? _cell$firstElementChi : 0;
      return paddingWidth + contentWidth;
    });
    var filteredWidths = options.includeOutliers ? widths : excludeOutliers(widths, options.outliersFactor);
    if (options.includeHeaders) {
      var header = findGridHeader(apiRef.current, column.field);
      if (header) {
        var title = header.querySelector(".".concat(gridClasses.columnHeaderTitle));
        var content = header.querySelector(".".concat(gridClasses.columnHeaderTitleContainerContent));
        var element = title != null ? title : content;
        var style = window.getComputedStyle(header, null);
        var paddingWidth = parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);
        var contentWidth = element.scrollWidth + 1;
        var width = paddingWidth + contentWidth;
        filteredWidths.push(width);
      }
    }
    var hasColumnMin = column.minWidth !== -Infinity && column.minWidth !== undefined;
    var hasColumnMax = column.maxWidth !== Infinity && column.maxWidth !== undefined;
    var min = hasColumnMin ? column.minWidth : 0;
    var max = hasColumnMax ? column.maxWidth : Infinity;
    var maxContent = filteredWidths.length === 0 ? 0 : Math.max.apply(Math, _toConsumableArray(filteredWidths));
    widthByField[column.field] = clamp(maxContent, min, max);
  });
  root.classList.remove(gridClasses.autosizing);
  return widthByField;
}
export var columnResizeStateInitializer = function columnResizeStateInitializer(state) {
  return _extends({}, state, {
    columnResize: {
      resizingColumnField: ''
    }
  });
};
/**
 * @requires useGridColumns (method, event)
 * TODO: improve experience for last column
 */
export var useGridColumnResize = function useGridColumnResize(apiRef, props) {
  var logger = useGridLogger(apiRef, 'useGridColumnResize');
  var colDefRef = React.useRef();
  var colElementRef = React.useRef();
  var headerFilterElementRef = React.useRef();
  var colGroupingElementRef = React.useRef();
  var colCellElementsRef = React.useRef();
  var theme = useTheme();

  // To improve accessibility, the separator has padding on both sides.
  // Clicking inside the padding area should be treated as a click in the separator.
  // This ref stores the offset between the click and the separator.
  var initialOffsetToSeparator = React.useRef();
  var resizeDirection = React.useRef();
  var stopResizeEventTimeout = useTimeout();
  var touchId = React.useRef();
  var updateWidth = function updateWidth(newWidth) {
    logger.debug("Updating width to ".concat(newWidth, " for col ").concat(colDefRef.current.field));
    var prevWidth = colElementRef.current.offsetWidth;
    var widthDiff = newWidth - prevWidth;
    colDefRef.current.computedWidth = newWidth;
    colDefRef.current.width = newWidth;
    colDefRef.current.flex = 0;
    colElementRef.current.style.width = "".concat(newWidth, "px");
    colElementRef.current.style.minWidth = "".concat(newWidth, "px");
    colElementRef.current.style.maxWidth = "".concat(newWidth, "px");
    var headerFilterElement = headerFilterElementRef.current;
    if (headerFilterElement) {
      headerFilterElement.style.width = "".concat(newWidth, "px");
      headerFilterElement.style.minWidth = "".concat(newWidth, "px");
      headerFilterElement.style.maxWidth = "".concat(newWidth, "px");
    }
    [].concat(_toConsumableArray(colCellElementsRef.current), _toConsumableArray(colGroupingElementRef.current)).forEach(function (element) {
      var div = element;
      var finalWidth;
      if (div.getAttribute('aria-colspan') === '1') {
        finalWidth = "".concat(newWidth, "px");
      } else {
        // Cell with colspan > 1 cannot be just updated width new width.
        // Instead, we add width diff to the current width.
        finalWidth = "".concat(div.offsetWidth + widthDiff, "px");
      }
      div.style.width = finalWidth;
      div.style.minWidth = finalWidth;
      div.style.maxWidth = finalWidth;
    });
  };
  var finishResize = function finishResize(nativeEvent) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    stopListening();
    if (colDefRef.current) {
      apiRef.current.setColumnWidth(colDefRef.current.field, colDefRef.current.width);
      logger.debug("Updating col ".concat(colDefRef.current.field, " with new width: ").concat(colDefRef.current.width));
    }
    stopResizeEventTimeout.start(0, function () {
      apiRef.current.publishEvent('columnResizeStop', null, nativeEvent);
    });
  };
  var handleResizeMouseUp = useEventCallback(finishResize);
  var handleResizeMouseMove = useEventCallback(function (nativeEvent) {
    // Cancel move in case some other element consumed a mouseup event and it was not fired.
    if (nativeEvent.buttons === 0) {
      handleResizeMouseUp(nativeEvent);
      return;
    }
    var newWidth = computeNewWidth(initialOffsetToSeparator.current, nativeEvent.clientX, colElementRef.current.getBoundingClientRect(), resizeDirection.current);
    newWidth = clamp(newWidth, colDefRef.current.minWidth, colDefRef.current.maxWidth);
    updateWidth(newWidth);
    var params = {
      element: colElementRef.current,
      colDef: colDefRef.current,
      width: newWidth
    };
    apiRef.current.publishEvent('columnResize', params, nativeEvent);
  });
  var handleTouchEnd = useEventCallback(function (nativeEvent) {
    var finger = trackFinger(nativeEvent, touchId.current);
    if (!finger) {
      return;
    }
    finishResize(nativeEvent);
  });
  var handleTouchMove = useEventCallback(function (nativeEvent) {
    var finger = trackFinger(nativeEvent, touchId.current);
    if (!finger) {
      return;
    }

    // Cancel move in case some other element consumed a touchmove event and it was not fired.
    if (nativeEvent.type === 'mousemove' && nativeEvent.buttons === 0) {
      handleTouchEnd(nativeEvent);
      return;
    }
    var newWidth = computeNewWidth(initialOffsetToSeparator.current, finger.x, colElementRef.current.getBoundingClientRect(), resizeDirection.current);
    newWidth = clamp(newWidth, colDefRef.current.minWidth, colDefRef.current.maxWidth);
    updateWidth(newWidth);
    var params = {
      element: colElementRef.current,
      colDef: colDefRef.current,
      width: newWidth
    };
    apiRef.current.publishEvent('columnResize', params, nativeEvent);
  });
  var handleTouchStart = useEventCallback(function (event) {
    var _apiRef$current$colum, _apiRef$current$colum2;
    var cellSeparator = findParentElementFromClassName(event.target, gridClasses['columnSeparator--resizable']);
    // Let the event bubble if the target is not a col separator
    if (!cellSeparator) {
      return;
    }
    // If touch-action: none; is not supported we need to prevent the scroll manually.
    if (!doesSupportTouchActionNone()) {
      event.preventDefault();
    }
    var touch = event.changedTouches[0];
    if (touch != null) {
      // A number that uniquely identifies the current finger in the touch session.
      touchId.current = touch.identifier;
    }
    colElementRef.current = findParentElementFromClassName(event.target, gridClasses.columnHeader);
    var field = getFieldFromHeaderElem(colElementRef.current);
    var colDef = apiRef.current.getColumn(field);
    colGroupingElementRef.current = findGroupHeaderElementsFromField((_apiRef$current$colum = apiRef.current.columnHeadersContainerElementRef) == null ? void 0 : _apiRef$current$colum.current, field);
    logger.debug("Start Resize on col ".concat(colDef.field));
    apiRef.current.publishEvent('columnResizeStart', {
      field: field
    }, event);
    colDefRef.current = colDef;
    colElementRef.current = findHeaderElementFromField((_apiRef$current$colum2 = apiRef.current.columnHeadersElementRef) == null ? void 0 : _apiRef$current$colum2.current, colDef.field);
    colCellElementsRef.current = findGridCellElementsFromCol(colElementRef.current, apiRef.current);
    resizeDirection.current = getResizeDirection(event.target, theme.direction);
    initialOffsetToSeparator.current = computeOffsetToSeparator(touch.clientX, colElementRef.current.getBoundingClientRect(), resizeDirection.current);
    var doc = ownerDocument(event.currentTarget);
    doc.addEventListener('touchmove', handleTouchMove);
    doc.addEventListener('touchend', handleTouchEnd);
  });
  var stopListening = React.useCallback(function () {
    var doc = ownerDocument(apiRef.current.rootElementRef.current);
    doc.body.style.removeProperty('cursor');
    doc.removeEventListener('mousemove', handleResizeMouseMove);
    doc.removeEventListener('mouseup', handleResizeMouseUp);
    doc.removeEventListener('touchmove', handleTouchMove);
    doc.removeEventListener('touchend', handleTouchEnd);
    // The click event runs right after the mouseup event, we want to wait until it
    // has been canceled before removing our handler.
    setTimeout(function () {
      doc.removeEventListener('click', preventClick, true);
    }, 100);
    if (colElementRef.current) {
      colElementRef.current.style.pointerEvents = 'unset';
    }
  }, [apiRef, colElementRef, handleResizeMouseMove, handleResizeMouseUp, handleTouchMove, handleTouchEnd]);
  var handleResizeStart = React.useCallback(function (_ref) {
    var field = _ref.field;
    apiRef.current.setState(function (state) {
      return _extends({}, state, {
        columnResize: _extends({}, state.columnResize, {
          resizingColumnField: field
        })
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  var handleResizeStop = React.useCallback(function () {
    apiRef.current.setState(function (state) {
      return _extends({}, state, {
        columnResize: _extends({}, state.columnResize, {
          resizingColumnField: ''
        })
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  var handleColumnResizeMouseDown = useEventCallback(function (_ref2, event) {
    var _apiRef$current$colum3, _apiRef$current$heade, _apiRef$current$colum4;
    var colDef = _ref2.colDef;
    // Only handle left clicks
    if (event.button !== 0) {
      return;
    }

    // Skip if the column isn't resizable
    if (!event.currentTarget.classList.contains(gridClasses['columnSeparator--resizable'])) {
      return;
    }

    // Avoid text selection
    event.preventDefault();
    logger.debug("Start Resize on col ".concat(colDef.field));
    apiRef.current.publishEvent('columnResizeStart', {
      field: colDef.field
    }, event);
    colDefRef.current = colDef;
    colElementRef.current = (_apiRef$current$colum3 = apiRef.current.columnHeadersContainerElementRef) == null ? void 0 : _apiRef$current$colum3.current.querySelector("[data-field=\"".concat(colDef.field, "\"]"));
    var headerFilterRowElement = (_apiRef$current$heade = apiRef.current.headerFiltersElementRef) == null ? void 0 : _apiRef$current$heade.current;
    if (headerFilterRowElement) {
      headerFilterElementRef.current = headerFilterRowElement.querySelector("[data-field=\"".concat(colDef.field, "\"]"));
    }
    colGroupingElementRef.current = findGroupHeaderElementsFromField((_apiRef$current$colum4 = apiRef.current.columnHeadersContainerElementRef) == null ? void 0 : _apiRef$current$colum4.current, colDef.field);
    colCellElementsRef.current = findGridCellElementsFromCol(colElementRef.current, apiRef.current);
    var doc = ownerDocument(apiRef.current.rootElementRef.current);
    doc.body.style.cursor = 'col-resize';
    resizeDirection.current = getResizeDirection(event.currentTarget, theme.direction);
    initialOffsetToSeparator.current = computeOffsetToSeparator(event.clientX, colElementRef.current.getBoundingClientRect(), resizeDirection.current);
    doc.addEventListener('mousemove', handleResizeMouseMove);
    doc.addEventListener('mouseup', handleResizeMouseUp);

    // Prevent the click event if we have resized the column.
    // Fixes https://github.com/mui/mui-x/issues/4777
    doc.addEventListener('click', preventClick, true);
  });
  var handleColumnSeparatorDoubleClick = useEventCallback(function (params, event) {
    if (props.disableAutosize) {
      return;
    }

    // Only handle left clicks
    if (event.button !== 0) {
      return;
    }
    var column = apiRef.current.state.columns.lookup[params.field];
    if (column.resizable === false) {
      return;
    }
    apiRef.current.autosizeColumns(_extends({}, props.autosizeOptions, {
      columns: [column.field]
    }));
  });

  /**
   * API METHODS
   */

  var columnVirtualizationDisabled = useColumnVirtualizationDisabled(apiRef);
  var isAutosizingRef = React.useRef(false);
  var autosizeColumns = React.useCallback( /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(userOptions) {
      var _apiRef$current$rootE, _userOptions$columns;
      var root, state, options, columns, widthByField, newColumns, _apiRef$current$getRo, _apiRef$current$getRo2, visibleColumns, totalWidth, availableWidth, remainingWidth, widthPerColumn;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            root = (_apiRef$current$rootE = apiRef.current.rootElementRef) == null ? void 0 : _apiRef$current$rootE.current;
            if (root) {
              _context.next = 3;
              break;
            }
            return _context.abrupt("return");
          case 3:
            if (!isAutosizingRef.current) {
              _context.next = 5;
              break;
            }
            return _context.abrupt("return");
          case 5:
            isAutosizingRef.current = true;
            state = gridColumnsStateSelector(apiRef.current.state);
            options = _extends({}, DEFAULT_GRID_AUTOSIZE_OPTIONS, userOptions, {
              columns: (_userOptions$columns = userOptions == null ? void 0 : userOptions.columns) != null ? _userOptions$columns : state.orderedFields
            });
            options.columns = options.columns.filter(function (c) {
              return state.columnVisibilityModel[c] !== false;
            });
            columns = options.columns.map(function (c) {
              return apiRef.current.state.columns.lookup[c];
            });
            _context.prev = 10;
            apiRef.current.unstable_setColumnVirtualization(false);
            _context.next = 14;
            return columnVirtualizationDisabled();
          case 14:
            widthByField = extractColumnWidths(apiRef, options, columns);
            newColumns = columns.map(function (column) {
              return _extends({}, column, {
                width: widthByField[column.field],
                computedWidth: widthByField[column.field]
              });
            });
            if (options.expand) {
              visibleColumns = state.orderedFields.map(function (field) {
                return state.lookup[field];
              }).filter(function (c) {
                return state.columnVisibilityModel[c.field] !== false;
              });
              totalWidth = visibleColumns.reduce(function (total, column) {
                var _ref4, _widthByField$column$;
                return total + ((_ref4 = (_widthByField$column$ = widthByField[column.field]) != null ? _widthByField$column$ : column.computedWidth) != null ? _ref4 : column.width);
              }, 0);
              availableWidth = (_apiRef$current$getRo = (_apiRef$current$getRo2 = apiRef.current.getRootDimensions()) == null ? void 0 : _apiRef$current$getRo2.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0;
              remainingWidth = availableWidth - totalWidth;
              if (remainingWidth > 0) {
                widthPerColumn = remainingWidth / (newColumns.length || 1);
                newColumns.forEach(function (column) {
                  column.width += widthPerColumn;
                  column.computedWidth += widthPerColumn;
                });
              }
            }
            apiRef.current.updateColumns(newColumns);
          case 18:
            _context.prev = 18;
            apiRef.current.unstable_setColumnVirtualization(true);
            isAutosizingRef.current = false;
            return _context.finish(18);
          case 22:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[10,, 18, 22]]);
    }));
    return function (_x) {
      return _ref3.apply(this, arguments);
    };
  }(), [apiRef, columnVirtualizationDisabled]);

  /**
   * EFFECTS
   */

  React.useEffect(function () {
    return stopListening;
  }, [stopListening]);
  useOnMount(function () {
    if (props.autosizeOnMount) {
      Promise.resolve().then(function () {
        apiRef.current.autosizeColumns(props.autosizeOptions);
      });
    }
  });
  useGridNativeEventListener(apiRef, function () {
    var _apiRef$current$colum5;
    return (_apiRef$current$colum5 = apiRef.current.columnHeadersElementRef) == null ? void 0 : _apiRef$current$colum5.current;
  }, 'touchstart', handleTouchStart, {
    passive: doesSupportTouchActionNone()
  });
  useGridApiMethod(apiRef, {
    autosizeColumns: autosizeColumns
  }, 'public');
  useGridApiEventHandler(apiRef, 'columnResizeStop', handleResizeStop);
  useGridApiEventHandler(apiRef, 'columnResizeStart', handleResizeStart);
  useGridApiEventHandler(apiRef, 'columnSeparatorMouseDown', handleColumnResizeMouseDown);
  useGridApiEventHandler(apiRef, 'columnSeparatorDoubleClick', handleColumnSeparatorDoubleClick);
  useGridApiOptionHandler(apiRef, 'columnResize', props.onColumnResize);
  useGridApiOptionHandler(apiRef, 'columnWidthChange', props.onColumnWidthChange);
};