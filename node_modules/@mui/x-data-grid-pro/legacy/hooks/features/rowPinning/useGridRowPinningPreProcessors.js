import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import * as React from 'react';
import { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';
import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';
import { insertNodeInTree } from '../../../utils/tree/utils';
export function addPinnedRow(_ref) {
  var _groupingParams$addit, _groupingParams$addit2;
  var groupingParams = _ref.groupingParams,
    rowModel = _ref.rowModel,
    rowId = _ref.rowId,
    position = _ref.position,
    apiRef = _ref.apiRef,
    isAutoGenerated = _ref.isAutoGenerated;
  var dataRowIdToModelLookup = _extends({}, groupingParams.dataRowIdToModelLookup);
  var dataRowIdToIdLookup = _extends({}, groupingParams.dataRowIdToIdLookup);
  var tree = _extends({}, groupingParams.tree);
  var treeDepths = _extends({}, groupingParams.treeDepths);

  // TODO: warn if id is already present in `props.rows`

  var node = {
    type: 'pinnedRow',
    id: rowId,
    depth: 0,
    parent: GRID_ROOT_GROUP_ID,
    isAutoGenerated: isAutoGenerated
  };
  insertNodeInTree(node, tree, treeDepths, null);
  if (!isAutoGenerated) {
    dataRowIdToModelLookup[rowId] = rowModel;
    dataRowIdToIdLookup[rowId] = rowId;
  }
  // Do not push it to ids list so that pagination is not affected by pinned rows

  apiRef.current.caches.rows.dataRowIdToModelLookup[rowId] = _extends({}, rowModel);
  apiRef.current.caches.rows.dataRowIdToIdLookup[rowId] = rowId;
  var previousPinnedRows = ((_groupingParams$addit = groupingParams.additionalRowGroups) == null ? void 0 : _groupingParams$addit.pinnedRows) || {};
  var newPinnedRow = {
    id: rowId,
    model: rowModel
  };
  if ((_groupingParams$addit2 = groupingParams.additionalRowGroups) != null && (_groupingParams$addit2 = _groupingParams$addit2.pinnedRows) != null && (_groupingParams$addit2 = _groupingParams$addit2[position]) != null && _groupingParams$addit2.includes(newPinnedRow)) {
    return _extends({}, groupingParams, {
      dataRowIdToModelLookup: dataRowIdToModelLookup,
      dataRowIdToIdLookup: dataRowIdToIdLookup,
      tree: tree,
      treeDepths: treeDepths
    });
  }
  return _extends({}, groupingParams, {
    dataRowIdToModelLookup: dataRowIdToModelLookup,
    dataRowIdToIdLookup: dataRowIdToIdLookup,
    tree: tree,
    treeDepths: treeDepths,
    additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {
      pinnedRows: _extends({}, previousPinnedRows, _defineProperty({}, position, [].concat(_toConsumableArray(previousPinnedRows[position] || []), [newPinnedRow])))
    })
  });
}
export var useGridRowPinningPreProcessors = function useGridRowPinningPreProcessors(apiRef) {
  var addPinnedRows = React.useCallback(function (groupingParams) {
    var _pinnedRowsCache$topI, _pinnedRowsCache$bott, _pinnedRowsCache$bott2, _pinnedRowsCache$topI2;
    var pinnedRowsCache = apiRef.current.caches.pinnedRows || {};
    var newGroupingParams = _extends({}, groupingParams, {
      additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {
        // reset pinned rows state
        pinnedRows: {}
      })
    });
    (_pinnedRowsCache$topI = pinnedRowsCache.topIds) == null || _pinnedRowsCache$topI.forEach(function (rowId) {
      newGroupingParams = addPinnedRow({
        groupingParams: newGroupingParams,
        rowModel: pinnedRowsCache.idLookup[rowId],
        rowId: rowId,
        position: 'top',
        apiRef: apiRef,
        isAutoGenerated: false
      });
    });
    (_pinnedRowsCache$bott = pinnedRowsCache.bottomIds) == null || _pinnedRowsCache$bott.forEach(function (rowId) {
      newGroupingParams = addPinnedRow({
        groupingParams: newGroupingParams,
        rowModel: pinnedRowsCache.idLookup[rowId],
        rowId: rowId,
        position: 'bottom',
        apiRef: apiRef,
        isAutoGenerated: false
      });
    });

    // If row with the same `id` is present both in `rows` and `pinnedRows` - remove it from the root group children
    if ((_pinnedRowsCache$bott2 = pinnedRowsCache.bottomIds) != null && _pinnedRowsCache$bott2.length || (_pinnedRowsCache$topI2 = pinnedRowsCache.topIds) != null && _pinnedRowsCache$topI2.length) {
      var shouldKeepRow = function shouldKeepRow(rowId) {
        if (newGroupingParams.tree[rowId] && newGroupingParams.tree[rowId].type === 'pinnedRow') {
          return false;
        }
        return true;
      };
      var rootGroupNode = newGroupingParams.tree[GRID_ROOT_GROUP_ID];
      newGroupingParams.tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroupNode, {
        children: rootGroupNode.children.filter(shouldKeepRow)
      });
      newGroupingParams.dataRowIds = newGroupingParams.dataRowIds.filter(shouldKeepRow);
    }
    return newGroupingParams;
  }, [apiRef]);
  useGridRegisterPipeProcessor(apiRef, 'hydrateRows', addPinnedRows);
};